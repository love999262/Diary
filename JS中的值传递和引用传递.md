# 是否了解值传递与引用传递是初级程序员与中级程序员的区别之一.

先看一段代码:

```js
var o = {
  a: '123',
  b: '456'
};
var _o = o;
_o.a = 'onetwothree';
console.log(o); 
console.log(_o);
console.log(o===_o); // true
```

- 问两次输出结果?
这里两次输出的结果都是一样的,而且对象也是恒等的,说明这两个对象指向同一处地址.

- 再看一段代码:

```js
var num1 = 5;
var num2 = num1;
num2 += 10;
console.log(num1);// 5
console.log(num2);// 10
```

- 这里的num1 num2是基本数据类型中的string类型,在进行赋值操作的时候并不会仅仅加个指向,而会在内存中开辟一块新的区间存储新的值,num1和num2所储存的值完全是独立的,而当一个变量向另一个变量赋值引用类型的值得时候仅是添加了一个指针,实际上指针指向的都是同一个对象,对任何指向改地址的变量操作都会改变其他指针指向的变量.

- 参数

首先明确一点:ES中所有函数的参数都是按值传递的,光看这句话可能有点模糊,看下面的代码:

```js
var count = 20;
function addTen(num) {
  num += 10;
  return num;
}
var result = addTen(count);
console.log(count); // 20
console.log(addTen(count));// 30
console.log(count);// 20
```

- 基本类型不必多说,下面我们来看引用类型:

```js
var o = {
  a: '123'
}
function test(_o) {
  _o.a = '456';
  return _o;
}
console.log(o);
console.log(test(o));
console.log(o);
```

- 这里的o.a分别为'123','456','456',可以看到,作为参数传入后更改属性后原来的o的属性也跟着改变了,那么是否就可以据此说引用类型的参数是引用传递呢?当然是不能的.

继续看一段代码:

```js
function test(_o) {
  __o = _o;
  __o.a = '456';
  __o = {};
  __o.a = '789';
}
var o = {a: '123'};
test(o);
console.log(o);
```

- 这里的o.a最终的结果是456,这说明即使在函数内部改变了参数的值,但是原始的引用依然未改变,事实上在函数内部重写obj的时候这个变量的引用就是一个局部对象的,这个局部对象会在函数执行完后被立即销毁.可能上面的例子举得还不是很清楚,看了之后会有点不明白,那么再看下面的额代码:

```js
var o = {
    a: '123'
}
function test(_o) {
    _o = 0;
}
console.log(o);//a:'123'
test(o);
console.log(o);//a:'123'
```

- 在执行完test(o)之后o的值依然没变,不会随着赋值的改变而改变,这是为什么呢,因为这里所谓的'值传递'实际上是将堆内存的内存地址赋值过去,对于对象来说永远存在于堆内存中,变量获取的永远都是对象的堆内存的内存地址,但是参数的传递也永远是值传递的方式来进行的,所以这个传递的值就是内存地址,而对obj内部的任意操作或者改动都会直接改动指针指向的内存地址中的数据,这并不影响他值传递的本质,因为只要不对对象内部进行操作而是直接将对象赋值为新的对象(重新赋值一个新的内存地址)或者赋值为一个新的基本数据类型(直接存放在在栈内存中)都不会影响原来对象的值.
