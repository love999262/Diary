# 程序设计的原则

## 单一职责原则

- 对于一个类/方法/对象来说,应该仅有一个引起他变化的原因,单一职责原则里的职责是指引起变化的原因,如果我们有多个动机去改写一个方法,那么这个方法就具有两个职责,每个职责都是变化额一根轴线,如果一个方法承担了过多的职责,那么在需求变迁的过程中,需要改写这个方法的可能性就越大.那么这个时候,这个方法通常是一个不稳定的方法,修改代码总是一件危险的事情,特别是当两个职责耦合在一起的时候,一个职责的变化可能会影响到其他职责的实现,造成意想不到的破坏,这种耦合性得到的是低内聚和脆弱的设计.单一职责原则体现为:一个方法只做一件事情.

## 最少知识原则

- 最少知识原则是说一个软件实体应当尽可能少地与其他实体发生相互作用,这里的软件实体是指一个广义的概念,不仅包括对象,还包括系统,类,模块,函数,变量等.举一个例子:某CEO想要让基层某员工做一个PPT以备他使用这个PPT在某顶级会议上演讲,那么会怎么做呢?CEO可能会让他的分管的副总裁通知分管VP通知FVP再通知对应的主管,主管通知组长,组长再将任务分配给对应的员工,这中间的调用大概是这样的:

```js
let ppt;

CEO(ppt).COO(ppt).VP(ppt).FVP(ppt).DIRECTOR(ppt).TEAMLEADER(ppt).TEAMMATE(ppt)

// 如此长的链式调用,并且如果在这里任何一个环节出了偏差可能最终的结果就会不正确
```

- 可能在现实生活中,在一个庞大的组织体系中,这样做是有必要的,但是这里不讨论社会学组织体系中的知识,在程序中这样做是显然不好的,我们应该尽可能的减少对象中的联系,单一职责原则让我们尽可能的将对象划分为较小的粒度,但是这样做也带来了一定的缺点,众多对象之间互相共同的影响着,如果改变了其中的一个对象,那么可能会影响到许许多多的与他相互引用的其他对象.最少知识原则则是要求我们在设计程序的时候,尽可能的减少对象之间的交互,如果两个对象之间不是一定必要彼此之间通信,那么就不要发生联系,常见的做法是引入一个第三者对象来承担这些对象的通信,如果需要通信可以通过第三者来进行.(中介者).
  - 中介者模式:打一个比方,在世界杯期间,博彩公司退出足彩的业务,大概有上千万的人会一起计算输赢和赔率,如果没有博彩公司这个中介,这件事情是不可能完成的,但是有博彩公司这个中介,每个人都与博彩公司发生关联,中介会根据所有人的投注情况计算赔率,最终结果出来之后也是博彩公司与彩民发生交易.

  - 封装:封装的目的是细节的隐藏,只留必要的接口给外接调用,让对象之间的联系限制在最小范围内,同时也限制了变量的作用域与生存周期,将变量限制在一个尽可能小的范围内,这个变量对其他不相关模块的影响就会越小,变量被改写或者与其他地方冲突的可能就会越少.这也是广义上最小知识原则的一种体现.

## 开放封闭原则

- 在OO语言程序设计中,开闭原则是最重要的一条,开放与封闭看似矛盾,其实不然,这里的开放是指对程序扩展的开放,封闭是指对实现细节的封闭,对内部修改的封闭.

- 假设有一个大型WEB项目,有10万行以上的JS代码和上百个JS文件,我们接到这样一个需求:在onload函数中输出页面上所有DOM节点的数量,这是一个很简单的需求,一般人的想法是用搜索找到window.onload然后在里面添加方法,在项目变迁和需求变动的过程中,经常会有这种类似的需求,我们第一时间想到的也是直接找到相关的代码去修改源码,然而改动源码常常是危险的,因为在大型项目中,你并不知道什么时候改了哪块地方就会埋下一个或几个不知道何时会触发的隐藏BUG,那么在不清楚代码的情况下就去修改代码是很危险的事情,假设onload是一个根据多层条件初始化的五百多行的巨型函数并且都是晦涩难懂的代码,再假设需求不是输出一个节点这么简单,那么这时候还应该去改动原来的代码吗?显然不是,这时候我们可以用动态装饰的方法,或者说回调的方法,.

- 尽量少用条件分支:过多的条件分支是造成程序违反开闭原则的一个常见原因,每当需要新增一个if语句的时候,都要被迫改动原来的函数,把if替换成switch-case并不能使程序变得更好,在大型项目中应该用继承多态的方式来尽量避免这一现象.

- 开闭原则比较晦涩,并没有严格的要求或者准则说要怎么做才能达到标准,不过还是有一些尽量需要去遵守的规律:
  1. 找出变化的地方,将变化的地方封装出来,这样可以让其他稳定的地方尽量少的接受一些改动.
  2. 钩子函数:我们在程序有可能发生变化的地方放置一个hook,hook函数的返回值决定了程序下一步的走向,这样,原本的代码执行路径上就会出现交叉路口,程序未来的执行就会出现多种可能.
  3. 回调函数:回调函数是一种特殊的挂钩模式,我们可以将一些变化封装在回调函数中,然后把回调函数作为参数传入一个稳定和封闭的函数中,当回调函数执行的时候,程序会因为回调函数内部逻辑的不同而产生不同的结果.